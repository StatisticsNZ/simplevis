---
title: "Leaflet"
author: "David Hodge"
date: "`r Sys.Date()`"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  warning = FALSE,
  fig.height = 4.5, 
  fig.width = 6
)
```

```{r}
library(simplevis)
library(stars)
set.seed(123456789)
```

### Overview

[leaflet](https://rstudio.github.io/leaflet/) is a library that provides beautiful html widget maps. This allow use of basemaps, and therefore the ability to zoom in on features with the context that these provide. simplevis provides wrapper functions to map `sf` and `stars` objects. Arguments in these have been aligned to ggplot terminology to make things simple for the user.

For the sf functions:

* Data must be an `sf` object 
* Data must be of `POINT`/`MULTIPOINT`, `LINESTRING`/`MULTILINESTRING`, or `POLYGON`/`MULTIPOLYGON` geometry type
* Data must have a coordinate reference system (CRS) defined
* No `x_var` and `y_var` variables are required

For the `stars` functions:

* Data must be a `stars` object 
* Data must have a coordinate reference system (CRS) defined
* No `x_var` and `y_var` variables are required

There is no facetting functionality provided for leaflet.

### Colouring 

Colouring is the same as that for graphs.

```{r}
leaf_sf_col(example_point, 
            col_var = trend_category)
```

```{r}
leaf_sf_col(example_polygon,  
            col_var = density)
```

```{r}
leaf_stars_col(example_stars, 
               col_var = nitrate, 
               col_method = "bin", 
               col_breaks_n = 4, 
               col_na_rm = TRUE)
```

```{r}
leaf_stars_col(example_stars, 
               col_var = nitrate, 
               col_method = "bin", 
               col_cuts = c(0, 500, 1000, 2000, Inf), 
               col_na_rm = TRUE)
```

```{r}
leaf_sf_col(example_polygon, 
            col_var = density, 
            col_method = "quantile", 
            col_breaks_n = 4)
```


```{r}
leaf_sf_col(example_polygon, 
            col_var = density, 
            col_method = "quantile", 
            col_cuts = c(0, 0.25, 0.5, 0.75, 0.95, 1))
```


```{r}
leaf_stars_col(example_stars, 
               col_var = nitrate, 
               col_method = "bin", 
               col_breaks_n = 7, 
               col_na_rm = TRUE)
```

### sf popups and hover text

The clickable popup will default to a `leafpop::popupTable` of all variables, but popups can be adjusted to a subset of column using the `popup_vars_vctr` argument.

```{r}
leaf_sf_col(example_point, 
            col_var = trend_category, 
            popup_vars_vctr = c("site_id", "median"))
```

The hover label will default to the colour variable, but can be adjusted using the `label_var` variable. 

```{r}
leaf_sf_col(example_point, 
            col_var = trend_category, 
            label_var = site_id)
```

### Basemaps

Users have a `basemap` argument that defaults to "light", but there are other options.

```{r}
leaf_sf(example_point, 
        basemap = "dark")
```

### Legend labels

Legend labels are not as flexible as in the ggplot2 wrapper functions. You can adjust by using the `col_labels` argument, and providing a manual vector of breaks. 

```{r}
leaf_sf_col(example_point, 
            col_var = trend_category, 
            col_labels = c("Better", "Same", "Worse"))
```

### Adding additional layers

As a leaflet object is produced, you can add additional layers with leaflet - although this may effect popups and labels. Note all objects provided to leaflet functions must be transformed to a CRS of 4326.

```{r}
leaf_sf_col(example_point, 
            col_var = trend_category) %>% 
  leaflet::addPolygons(data = sf::st_transform(example_borders, 4326),
                       color = "#35B779", 
                       weight = 3, 
                       fillOpacity = 0, 
                       opacity = 1)
```

### leaflet basemap stack for shiny

A leaflet basemap stack is available for use in shiny apps. It defaults to the top layer being "light". You can set the bounds by adding a vector or bbox of bounds.

```{r}
leaf_basemap(bounds = c(166.70047,-34.45676, 178.52966,-47.06345))
```

You can also specify the basemap top layer.

```{r}
bb <- rnaturalearth::ne_countries(scale = "small", 
                                  country = "Indonesia", 
                                  returnclass = "sf") %>% 
   sf::st_bbox() 
 
leaf_basemap(bounds = bb, basemap = "satellite") 
```

### Layer id's for use in shiny

You can add a `layer_id` variable to leaf_sf* functions for use in shiny, which enables you to return a value when the value is clicked on.

This enables you to program shiny to do specific things when a feature is clicked upon.

For example, if the server.R code downloaded from `shiny_demo()` is updated as follows, a modal dialog can be created with a graph that compares a feature value with the distribution of all values. 

* In `server.R`, adjust your `leaf_sf*` function by adding a `layer_id` variable and then turning the default popup to FALSE.

```{r, eval = F}
  leaf_sf_col(
    leaf_data(),
    col_var = trend_category,
    size_point = size_reactive,
    col_title = title, 
    layer_id_var = site_id,
    popup = FALSE
  )

```

* Then in `server.R`, add `ObserveEvent` code to observe when a feature is clicked on, and then add some code to put something something in a modal dialog box. 

```{r, eval=F}
  observeEvent(input$leaf_marker_click, {
    
    site_median <- leaf_data() %>% 
      filter(site_id == input$leaf_marker_click$id) %>% 
      pull(median)
    
    showModal(
      modalDialog(
        renderPlot(
          gg_histogram(example_point, median, 
                       title = paste0(input$leaf_marker_click$id, " compared to all sites"), 
                       theme = gg_theme(font = "Helvetica", size_title = 16,  size_body = 15, gridlines_h = T)) +
            ggplot2::geom_vline(ggplot2::aes(xintercept = site_median), col = "red")
        ),
        easyClose = TRUE
      )
    )
  })
  
```

Note that the `input$leaf_marker_click$id` returns the value of the variable assigned to the `layer_id`. The click event returns `input$leaf_marker_click` in this example because the map_id defaults to "leaf" and this relates to a circlemarker. Refer [here](https://rstudio.github.io/leaflet/shiny.html) for more information.
