---
title: "Simplevis"
author: "David Hodge"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Simplevis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  warning = FALSE,
  fig.height = 3.5, 
  fig.width = 6
)
```

```{r, message=FALSE, warning=FALSE}
library(dplyr)
library(simplevis)
library(palmerpenguins)
```

### Purpose 

simplevis is a package of wrapper functions that aims to make fantastic ggplot2 visualisation <i>easier</i> and <i>quicker</i> for users. 

### Visualisation family types

`simplevis` supports the following families of visualisation type:

point

```{r}
gg_point(iris, Sepal.Width, Sepal.Length)
```

vbar (i.e vertical bar)

```{r}
plot_data <- storms %>%
  group_by(year) %>%
  summarise(wind = mean(wind))

gg_vbar(plot_data, year, wind)
```

hbar (i.e horizontal bar)

```{r}
plot_data <- storms %>%
  group_by(year) %>%
  summarise(wind = mean(wind))

gg_hbar(plot_data, wind, year)
```



* boxplot

```{r}
gg_boxplot(storms, year, wind)
```

line

```{r}
plot_data <- storms %>%
  group_by(year) %>%
  summarise(wind = mean(wind))

gg_line(plot_data, year, wind)
```

* sf (short for simple features map)

```{r}
gg_sf(example_sf_point, borders = nz)
```

### Colouring, facetting, neither or both

Each visualisation family generally has 4 functions.

The function name specifies whether or not a visualisation is to be coloured by a variable (`*_col()`), facetted by a variable (`*_facet()`), or neither (`*()`) or both of these (`_col_facet()`). 

Colouring by a variable means that different values of a selected variable are to have different colours. Facetting means that different values of a selected variable are to have their facet.

A `*()` function such `gg_point()` requires only a dataset, an x variable and a y variable. 

```{r}
gg_point(penguins, bill_length_mm, body_mass_g)
```

A `*_col()` function such `gg_point_col()` requires only a dataset, an x variable, a y variable, and a colour variable. 

```{r}
gg_point_col(penguins, bill_length_mm, body_mass_g, species)
```

A `*_facet()` function such `gg_point_facet()` requires only a dataset, an x variable, a y variable, and a facet variable. 

```{r}
gg_point_facet(penguins, bill_length_mm, body_mass_g, species)
```

A `*_col_facet()` function such `gg_point_col_facet()` requires only a dataset, an x variable, a y variable, a colour variable, and a facet variable. 

```{r}
gg_point_col_facet(penguins, bill_length_mm, body_mass_g, sex, species)
```

Data is generally plotted with a stat of `identity`, which means data is plotted as is. Only for boxplot, there is a different default stat of boxplot, which means data will be transformed to boxplot statistics. 

`_sf` functions for maps differ slightly, which is discussed further below.  

### Titles

Customise titles with `title`, `subtitle`, `x_title`, `y_title` and `caption` arguments. 

```{r}
gg_point_col(penguins, bill_length_mm, body_mass_g, species, 
             title = "Adult penguin mass by bill length and species",
             subtitle = "Palmer station, Antarctica",
             x_title = "Bill length (mm)", 
             y_title = "Body mass (g)",
             col_title = "Species type",
             caption = "Source: Gorman KB, Williams TD, Fraser WR (2014)")
```

Defaults titles are: 

 * no title, subtitle or caption 
 * x, y and colour titles are converted to sentence case using the `snakecase::to_sentence_case` function. You can turn this transformation off to use variable names as is using `x_title = ggplot2::waiver()` or likewise for `y_title` and `col_title`. You can also request no x_title using `x_title = ""` or likewise for `y_title` and `col_title`.

### Colour palettes.

Change the colour palette by supplying a vector of colours to the `pal` argument. 

```{r}
gg_point(iris, Sepal.Width, Sepal.Length, pal = "#e7298a")

```

### Scale transformations

simplevis makes it easy to make easy scale transformations.

These use consistent prefixes based on `x_*`, `y_*`, `col_*` or `facet_*`, and as such the autocomplete can help identify what you need.

Common transformations are `*_zero` or `*_labels`.

```{r}
plot_data <- storms %>%
  group_by(year) %>%
  summarise(wind = mean(wind))

gg_line(plot_data, year, wind, 
        y_zero = T, 
        y_labels = scales::dollar_format())
```

### `sf` maps

`simplevis` provides simple feature (`sf`) maps (i.e. maps with point, line or polygon features). 

These functions work in the same way as the ggplot2 graph functions, but with the following noteworthy differences:

* Data must be an `sf` object 
* Data must be of `POINT`/`MULTIPOINT`, `LINESTRING`/`MULTILINESTRING`, or `POLYGON`/`MULTIPOLYGON` geometry type
* Data must have a coordinate reference system (CRS) defined
* No `x_var` and `y_var` variables are required
* Borders can added to maps by providing an `sf` object to the `borders` argument. 

A couple of example sf objects are provided with the package for learning purposes: `example_sf_point` and `example_sf_polygon`.

```{r}
gg_sf_col(example_sf_point, trend_category, 
          size_point = 0.5,
          pal = c("#4575B4", "#D3D3D3", "#D73027"))
```

The borders argument allows for the user to provide an sf object as context to the map (e.g. a coastline or administrative bounrdaries). An sf object of the New Zealand coastline has been provided for learning purposes with the package.

```{r}
gg_sf_col(example_sf_point, trend_category,
          borders = nz, 
          size_point = 0.5,
          pal = c("#4575B4", "#D3D3D3", "#D73027"))

```

As a bonus, simplevis also provides `leaflet` and `leaflet_sf` functions, which work in a similar way. 

```{r}
leaflet_sf_col(example_sf_point, trend_category,
          size_point = 0.5,
          pal = c("#4575B4", "#D3D3D3", "#D73027"))
```

### supported variable classes

variable types supported by the different groups of functions are outlined below.

A stat of `identity` refers to the value being plotted as it is. A stat of `boxplot` refers to boxplot statistics being calculated from the data, and these plotted.

```{r, message = FALSE, warning = FALSE, fig.width = 7}
tibble::tribble(
  ~type, ~data, ~x_var, ~y_var, ~col_var, ~facet_var, ~stat,
  "vbar", "tibble or data.frame", "Any", "Numeric", "Categorical or numeric", "Categorical", "Identity",
  "hbar", "tibble or data.frame", "Numeric", "Any", "Categorical or numeric", "Categorical", "Identity",
  "line", "tibble or data.frame", "Any", "Numeric", "Categorical or numeric", "Categorical", "Identity",
  "point", "tibble or data.frame", "Any", "Numeric", "Categorical or numeric", "Categorical", "Identity",
  "boxplot", "tibble or data.frame", "Any", "Numeric", "Categorical", "Categorical", "Boxplot or identity",
  "sf", "sf", NA, NA, "Categorical or numeric", "Categorical", "Identity",
  ) %>% 
  DT::datatable()
```

### Output objects

All `gg_*` and `leaflet_*` wrapper functions produce ggplot or leaflet objects.

This mean layers can be added to the functions in the same way you would a ggplot2 or leaflet object.

Note you need to add all aesthetics to any additional layers.

```{r}
gg_point_col(penguins, bill_length_mm, body_mass_g, species) +
  ggplot2::geom_smooth(ggplot2::aes(bill_length_mm, body_mass_g, col = species))

```

### ggplotly interactive visualisation

All ggplot objects can be converted into interactive html objects using ggplotly. 

Simply wrap the plot object in `plotly::ggplotly` as follows:

```{r, eval = FALSE}
plot <- gg_point_col(penguins, bill_length_mm, body_mass_g, species)

plotly::ggplotly(plot) %>% 
  plotly_camera()
```

### Further information

For further information, see the articles on the [website](https://statisticsnz.github.io/simplevis/).